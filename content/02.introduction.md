## Introduction ##

Bioinformatics and computational biology are indispensable components of research in biology.
About 90% of researchers rely on results produced by scientific software [@doi:10.1109/MIC.2014.88].
In turn, scientists are heavily relying on inventions of computer science and software engineering, such as programming languages, programming paradigms, or container solutions.
However, adopting practices from other fields is not without difficulties and scientific software development tends to lag behind.
One implication of using outdated or poor software engineering practices is that incorrect software may result in invalid scientific findings [@doi:10.1109/MIC.2014.88; @doi:10.7717/peerj-cs.839].
Beyond that, even when the software performs as intended, researchers can spend a significant amount of time on software building using suboptimal practices which can further increase necessary time investments in the future [@doi:10.1016/j.jss.2020.110848; @{https://c2.com/doc/oopsla92.html}; @doi:10.1145/2160718.2160733].

To mitigate the risk of incorrect software solutions and save development time in the long run, good software development practices (e.g. pair programming, code reviews) have been established in other software-heavy endeavours. <!-- Sentence sounds a bit strange to me. Use "fields" instead of "endeavours"? -->
However, bioinformaticians or more generally scientists working with scientific software often lack formal education in computer science or software development [@doi:10.1109/SECSE.2009.5069155; @doi:10.7717/peerj-cs.839; @doi:10.1371/journal.pcbi.1005412].
This may hinder the adoption of good coding practices (e.g. unit tests, continuous integration).
In addition, research projects are often carried by a single trainee and are part of academic degree evaluation. <!-- The 2nd part of this sentence is not clear to me (why is this a problem), consider expanding on it a bit -->
Thus, software developed for a particular project is mostly limited to the skills of an individual person, does not follow many software development guidelines, and can remain poorly maintained after the end of the project [@doi:10.1101/2022.03.10.483804; @doi:10.1371/journal.pone.0205898; @doi:10.1371/journal.pcbi.1005412; @doi:10.1145/1852786.1852802].
One way to expand the knowledge and application of good software quality practices is to rely on other experts and make use of knowledge redundancy. <!-- "people around" sounds very informal. It is not clear how one can make use of a redundancy. I guess what you are trying to say here is that you want to avoid redundancy by combining forces, so that a problem is only encountered once? Or did you want to highlight something else? -->
We suggest that practices from the field of software development, such as code reviews, can be repurposed as learning opportunities.

Currently, in research-oriented environments, what specifically defines a ``team" is perceived differently compared to how this is defined in the software development. <!-- consider rephrasing -->
In research groups, group members generally discuss and help each other with scientific suggestions, but most often a single person designs and implements the code base to answer scientific questions. <!-- "is designing and implementing" seems to suggest it is just done at a specific instance" -->
Without shared standards, the available guidelines on coding practices are only suggestive and often anecdotal.
As following or ignoring these guidelines is usually up to individual judgment, the actual craft of software engineering is often treated as an afterthought.
However, when software is developed by multiple group members, researchers tend to appreciate software engineering concepts [@doi:10.1109/SECSE.2009.5069155].
High-profile code bases often feature larger development teams and their activities indicate better communication and software documentation [@doi:10.1371/journal.pone.0205898]. <!-- grammar sounds strange to me, as it seems the code base is doing something actively. Consider rewriting. Also, consider splitting the sentence in 2, as the "and" seems to connect 2 different things (shorter is better in English).-->
To summarize, systematic adoption of team coding practices homogenizes software engineering competence of individuals across the research group and contributes to the dynamism of the research environment. <!--unsure what is being summarized here-->
We hypothesize that a form of team structure organized around individual software products could improve the quality of our scientific code.
According to the literature, we expect an increased validity and reproducibility of scientific findings, as well as better maintenance of our computational resources for the community [@doi:10.1093/nar/gkad1059; @doi:10.1186/s13059-023-02877-1].

In this work, we first review relevant literature on the individual and team coding practices that are currently suggested within and outside scientific research groups.
To overcome the obstacles limiting researchers to adopt good practices, we present our groups' approach, where we learn, teach, and apply concepts to improve the quality of our software products in a team setting.
We created weekly meetings and code review sessions, in which group members discuss aspects of software quality relevant for computational biology and show their own code to the rest of the group to discuss and review.
We suggest that our team-based activities result in shared standards and an overall better code quality with a reduced effort on an individual level.
Furthermore, we provide a framework on how to get started with collective software development by directly or indirectly involving all bioinformatician group members, including those who have, and who do not have formal training in software engineering.

With this work we want to emphasize that good software quality can be learned through collaborative effort.
We offer a visual metaphor, where improvement of software quality is like an exercise of rock-climbing (**Figure 1**).
At the top of the rock is our goal of good quality software.
Specifically, we identified reliable, performant, and extensible software as our aim, as we wished to improve our skills in creating and maintaining a lasting piece of software as is the scope of our teams [@doi:10.1093/nar/gkad1059 ; @doi:10.1186/s13059-023-02877-1].
In order to reach it, we need to become proficient in the various concepts depicted by the holds.
These concepts were selected from the literature and our professional experience, but are not exhaustive and can be tailored to the specific needs of each group.
The higher they are on the wall, the more advanced we consider the concepts to be.
As the progress is cumulative, we have chosen to show the holds in the same colour if they represent related concepts that build upon each other.
This way, we mimic traditional CS education.
We found reiterating certain core concepts (e.g., modularization, testing) valuable.
The actual order of visiting the topics and emphasis on them can vary between groups.
The most important point, however, is the fact that rock climbing requires a partner to belay you, just as we believe the input of other people helps us become better programmers.

![***Figure 1:*** **An illustration comparing the process of improvement in software writing to rock climbing.**
DSA: data structures and algorithms, OOP: object-oriented programming, UML: Unified Modelling Language, CI: continuous integration, SCA: static code analysis](content/images/wall_climbing.png "Wall climbing"){height="700px"}
